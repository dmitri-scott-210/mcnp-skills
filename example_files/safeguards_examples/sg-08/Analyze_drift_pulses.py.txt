#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jul  8 08:39:07 2021

@author: swoldegiorgis
"""

import numpy as np
import matplotlib
matplotlib.use('Agg')
from matplotlib import pylab as plt


params = {
    'axes.labelsize': 10,
    'font.size': 10,
    'legend.fontsize': 10,
    'xtick.labelsize': 10,
    'ytick.labelsize': 10,
    'text.usetex': False,
    'figure.figsize': [5.5, 4.5]
    }
matplotlib.rcParams.update(params)


class DRiFT_pulse_analyser(object):
    
    '''
    =============================================================================
    Performing PSD and cross-correlation analysis of neutron and gamma-ray pulses
    generated by DRiFT.
    =============================================================================
    '''
    
    def __init__(self,
                 drift_neutron_pulse_data,
                 drift_gamma_ray_pulse_data,
                 drift_event_summary_output,
                 show_plots = True):
        self.neutron_pulse_data = drift_neutron_pulse_data
        self.gamma_ray_pulse_data = drift_gamma_ray_pulse_data
        self.drift_event_summary_output = drift_event_summary_output
        self.show_plots = show_plots

        '''  
        Cf252 neutron pulses
        '''
        ptrac_output = self.neutron_pulse_data
        drift_pulse_data = open(ptrac_output).read().splitlines()

        drift_pulses = []
        for pulse in drift_pulse_data[1:]:
            drift_pulses.append([int(i) for i in pulse.split()])
    
        # Convert the list into numpy array for a more convinient analysis
        drift_pulses = np.asarray(drift_pulses)
        # Add a column of neutron (1) label to pulse data
        drift_pulses = np.concatenate((drift_pulses, np.ones((drift_pulses.shape[0], 1))), 
                                  axis = 1) 

        '''  
        Co60 photon pulses
        '''
        ptrac_output_2 = self.gamma_ray_pulse_data
        drift_pulse_data_2 = open(ptrac_output_2).read().splitlines()

        drift_pulses_2 = []
        for pulse in drift_pulse_data_2[1:]:
            drift_pulses_2.append([int(i) for i in pulse.split()])
    
        # Convert the list into numpy array for a more convinient analysis
        drift_pulses_2 = np.asarray(drift_pulses_2)
        # Add a column of gamma-ray (2) label to pulse data
        drift_pulses_2 = np.concatenate((drift_pulses_2, np.ones((drift_pulses_2.shape[0], 1)) + 1), 
                                        axis = 1) 

        '''
        Combine all pulse data
        '''
        self.drift_pulses_all = np.concatenate((drift_pulses, 
                                                drift_pulses_2),
                                               axis = 0)
        
        # Indices of neutron and gamma-ray pulses
        self.n_idx = np.where(self.drift_pulses_all[:, -1] == 1)[0]
        self.g_idx = np.where(self.drift_pulses_all[:, -1] == 2)[0]

    '''
    PSD METHOD 1: CC
    '''
    def psd_cc(self, int_start_idx = 8, show_plot = True):
        '''
        The Charge Comparison (CC) method - used in a numerous previous works

        Parameters
        ----------
        pulses : Numpy arr
            Array of all pulses data, including neutron and gamma-ray pulses.
        int_start_idx : int, optional
            Starting point for slow component integration in terms of pulse points follwing maximum amplitude. The default is 3.
        show_plot : str, optional
            Choose between displaying or not displaying plots at the end of computation. The default is True.

        Returns
        -------
        long_gate : Numpy arr
            Array of long gate (total integration) integration infomration for each pulse.
        short_gate : Numpy arr
            Array of short gate (slow component) integration information for each pulse.

        '''
    
        # find the max point for each pulse
        max_idx = np.argmax(self.drift_pulses_all[:, :-1], axis = 1)
    
        # starting point for slow-component integration few data points after maximum
        max_idx += int_start_idx
    
        # slow and total component of the pulse 
        self.short_gate = np.array([np.sum(self.drift_pulses_all[i, :-1][max_idx[i]:]) for i in range(len(self.drift_pulses_all))])
        self.long_gate = np.sum(self.drift_pulses_all[:, :-1], axis = 1)
    
        # fast component of the pulse
        self.fast_integral = np.array([np.sum(self.drift_pulses_all[i, :-1][max_idx[i] - int_start_idx - 2 : max_idx[i]]) for i in range(len(self.drift_pulses_all))])
        
    
        return self.fast_integral, self.short_gate



    '''
    PSD METHOD 2: PGA
    '''
    def psd_pga(self, sec_amp_idx = 8, show_plot = True):
        '''
        The Pulse Gradient Analysis (PGa) method

        Parameters
        ----------
        pulses : Numpy arr
            Array of all pulses data, including neutron and gamma-ray pulses.
        sec_amp_idx : int, optional
            Location of second amplitude, in terms of number of pulse point following maximum pulse amplitude. The default is 8.
        show_plot : str, optional
            Choose between displaying or not displaying plots at the end of computation. The default is True.

        Returns
        -------
        Max_amplitude : Numpy arr
            Maximum amplitude of each pulse.
        Ratio : Numpy arr
            Ratio (maximum / second amplitude) of amplitudes for each pulse.

        '''
    
        # find the max point for each pulse
        self.max_idx = np.argmax(self.drift_pulses_all[:, :-1], axis = 1)
    
        # location of second amplitude
        self.sec_max_idx = self.max_idx + sec_amp_idx
    
        # Maximum and second pulse amplitude
        self.Max_amplitude = np.array([self.drift_pulses_all[i, self.max_idx[i]] for i in range(len(self.drift_pulses_all))])
        self.Sec_amplitude = np.array([self.drift_pulses_all[i, self.sec_max_idx[i]] for i in range(len(self.drift_pulses_all))])
    
        # Ratio of the two amplitudes
        self.Ratio = self.Sec_amplitude / self.Max_amplitude
    
    
        return self.Max_amplitude, self.Ratio



    '''
    PSD METHOD 3: SDCC
    '''
    def psd_sdcc(self, int_start_idx = 8, show_plot = True):
        '''
        The Simple Digital Charge Comparison (SDCC) method

        Parameters
        ----------
        pulses : Numpy arr
            Array of all pulses data, including neutron and gamma-ray pulses.
        int_start_idx : int, optional
            Starting point for slow component integration in terms of pulse points follwing maximum amplitude. The default is 8.
        show_plot : str, optional
            Choose between displaying or not displaying plots at the end of computation. The default is True.

        Returns
        -------
        Max_amplitude : Numpy arr
            The maximum amplitude of each pulse.
        Discrimination_param : Numpy arr
            The discrimination parameter used by the sdcc method, for each pulse.

        '''
    
        # starting location for the integration
        int_start = self.max_idx + int_start_idx
    
        # Discrimination parameter used by the sdcc parameter
        squared_sum = np.array([np.sum(self.drift_pulses_all[i, :-1][int_start[i]:] ** 2) for i in range(len(self.drift_pulses_all))])
        self.Discrimination_param = np.log(squared_sum)
    
    
        return self.Discrimination_param
    
    
    
    def generate_plots(self):
        '''
        Returns
        -------
        Generate plots showing:
            1. Sample neutron and gamma-ray pulses
            2. PSD results based on CC method
            3. PSD results based on PGA method
            4. PSD results based on SDCC method

        '''
        
        if self.show_plots:
            fig, ax = plt.subplots(nrows = 2, ncols = 2, figsize = (20,20))
            
            colors = ['C0', 'C1', 'C2']
            for i in np.arange(0, 5):
                n_pulse = self.drift_pulses_all[self.n_idx[i], :-1]
                n_label = self.drift_pulses_all[self.n_idx[i], -1].astype(int)
                g_pulse = self.drift_pulses_all[self.g_idx[i], :-1]
                g_label = self.drift_pulses_all[self.g_idx[i], -1].astype(int)
                if i == 0:
                    ax[0, 0].plot(n_pulse, color = colors[n_label], label = "Cf-252 neutron pulses")
                    ax[0, 0].plot(g_pulse, color = colors[g_label], label = "Co-60 gamma-ray pulses")
                else:
                    ax[0, 0].plot(n_pulse, color = colors[n_label])
                    ax[0, 0].plot(g_pulse, color = colors[g_label])
            ax[0, 0].set_title('Sample pulses')
            ax[0, 0].set_xlabel('Pulse length')
            ax[0, 0].set_ylabel('Pulse amplitude [a.u]')
            ax[0, 0].legend()
            
            # Extract PSD parameters 
            fast_integral, short_gate = self.psd_cc()
            max_amp, ratios = self.psd_pga()
            disc_param = self.psd_sdcc()
    
            # PSD plot using the CC method
            ax[0, 1].scatter(fast_integral[self.n_idx], short_gate[self.n_idx], s = 10,  
                          facecolor = 'none', edgecolor = 'C1', label = 'Cf-252 neutrons')
            ax[0, 1].scatter(fast_integral[self.g_idx], short_gate[self.g_idx], s = 10,  
                          facecolor = 'none', edgecolor = 'C2', label = 'Co-60 gamma-rays')
            ax[0, 1].set_title('PSD: CC method')
            ax[0, 1].set_xlabel('Fast component integration [a.u]')
            ax[0, 1].set_ylabel('Slow component integration [a.u]')
            ax[0, 1].legend()
            
            # PSd plot using the PGA method
            ax[1, 0].scatter(max_amp[self.n_idx], ratios[self.n_idx], s = 10, 
                          facecolor = 'none', edgecolor = 'C1', label = 'Cf-252 neutrons')
            ax[1, 0].scatter(max_amp[self.g_idx], ratios[self.g_idx], s = 10,  
                          facecolor = 'none', edgecolor = 'C2', label = 'Co-60 gamma-rays')
            ax[1, 0].set_title('PSD: PGA method')
            ax[1, 0].set_xlabel('Maximum pulse amplitude [V]')
            ax[1, 0].set_ylabel('Ratio of amplitudes')
            ax[1, 0].legend()
            
            # PSD plot using the SDCC method
            ax[1, 1].scatter(max_amp[self.n_idx], disc_param[self.n_idx], s = 10, 
                          facecolor = 'none', edgecolor = 'C1', label = 'Cf-252 neutrons')
            ax[1, 1].scatter(max_amp[self.g_idx], disc_param[self.g_idx], s = 10, 
                          facecolor = 'none', edgecolor = 'C2', label = 'Co-60 gamma-rays')
            ax[1, 1].set_title('PSD: SDCC method')
            ax[1, 1].set_xlabel('Maximum pulse amplitude [V]')
            ax[1, 1].set_ylabel('Discrimination parameter, D')
            ax[1, 1].legend()
            
            fig.tight_layout()
            fig.savefig('Samples_of_drift_generated_pulses_and_PSD_results.png')

            
            
    def neutron_neutron_doubles(self, show_corr_histogram = True):
        '''

        Parameters
        ----------
        show_corr_histogram : bool, optional
            Choose whethere or not to display the histogram of n-n cross-correlations. The default is True.

        Returns
        -------
        n_n_correlations : Numpy arr
            The neutron-neutron cross-correlations summary. The first row shows correlation angles,
            whereas the second row shows the corresponding counts

        '''
        
        # Extract infomration needed for correlation analysis from 
        # drift event summary output file (separate from detector pulse shape file)
        ptrac_output = self.drift_event_summary_output
        column_data = open(ptrac_output, "r").readlines()
        self.nps = [] 
        self.det_cells = []
        self.cor_count = []
        for line in column_data[3:]:
            self.nps.append(int(line.split()[2]))
            self.det_cells.append(int(line.split()[4]))
            self.cor_count.append(str(line.split()[5]))
        
        # Convert the list into numpy array for a more convinient analysis
        self.nps = np.asarray(self.nps)
        self.det_cells = np.asarray(self.det_cells)
        self.cor_count = np.asarray(self.cor_count)
        
        # Find correlated (double) events, extracting the detector cells where the first 
        # and the second detections occured. This will be used to determine the correlation angle. 
        self.doubles_idx = np.where(self.cor_count == 'double')[0]
        self.first_event_det = self.det_cells[self.doubles_idx[0::2]] # detector number for first event
        self.second_event_det = self.det_cells[self.doubles_idx[1::2]] # detector number for second event
        
        # List of (mcnp) cells for the active volumes of the 5 detectors
        list_of_det = [2003, 2103, 2203, 2303, 2403] # 45 deg angle between consecutive detectors
        deg_45_pairs = [[2103], [2003, 2203], [2103, 2303], [2203, 2403], [2303]]
        deg_90_pairs = [[2203], [2303], [2003, 2403], [2103], [2203]]
        deg_135_pairs = [[2303], [2403], [None], [2003], [2103]]
        deg_180_pairs = [[2403], [None], [None], [None], [2003]]
        
        
        # List of possible correlation angles for doubles events
        count_45 = 0
        count_90 = 0
        count_135 = 0
        count_180 = 0
        
        for i in range(len(self.first_event_det)):
            first_det = self.first_event_det[i]
            second_det = self.second_event_det[i]
            for j in range(len(list_of_det)):
                
                ''' 
                Accumulate 45 degree n-n correlation counts
                '''
                for k in range(len(deg_45_pairs[j])):
                    if first_det == list_of_det[j] and second_det == deg_45_pairs[j][k]:
                        count_45 += 1
                                
                ''' 
                Accumulate 90 degree n-n correlation counts
                '''            
                for k in range(len(deg_90_pairs[j])):
                    if first_det == list_of_det[j] and second_det == deg_90_pairs[j][k]:
                        count_90 += 1
                                
                ''' 
                Accumulate 135 degree n-n correlation counts
                '''            
                for k in range(len(deg_135_pairs[j])):
                    if first_det == list_of_det[j] and second_det == deg_135_pairs[j][k]:
                        count_135 += 1
                
                ''' 
                Accumulate 180 degree n-n correlation counts
                '''            
                for k in range(len(deg_180_pairs[j])):
                    if first_det == list_of_det[j] and second_det == deg_180_pairs[j][k]:
                        count_180 += 1
                                
                    
        self.n_n_corr_angles = np.asarray([45, 90, 135, 180])
        self.n_n_corr_counts = np.asarray([count_45,
                                           count_90,
                                           count_135,
                                           count_180])
        
        if show_corr_histogram:
            fig, ax = plt.subplots(1,1)
            ax.scatter(self.n_n_corr_angles, self.n_n_corr_counts, marker = "s", c = 'k')
            ax.set_xlabel('n-n correlation angles [degree]')
            ax.set_ylabel('Counts')
            ax.set_xticks([45, 90, 135, 180])
            fig.tight_layout()
            fig.savefig('neutron_neutron_cross_correlations.png')
            
        
        self.n_n_correlations = np.vstack((self.n_n_corr_angles,
                                           self.n_n_corr_counts))
        # Save summary of the cross-correlation analysis to a text file
        np.savetxt('neutron_neutron_cross_correlations_summary.txt', self.n_n_correlations.astype(int), delimiter=',')
        
        return self.n_n_correlations
    

# Run the code and generate post-processing outputs 
neutron_pulse_data = 'drift_output_corr_cf252_neutrons_pulse_shape'
gamma_ray_pulse_data = 'drift_output_corr_co60_gamma_rays_pulse_shape'
drift_event_summary_output = 'drift_output_corr_cf252_neutrons'

psd_cross_corr = DRiFT_pulse_analyser(neutron_pulse_data, 
                                      gamma_ray_pulse_data,
                                      drift_event_summary_output)

psd_plots = psd_cross_corr.generate_plots()

nn_correlations = psd_cross_corr.neutron_neutron_doubles()












