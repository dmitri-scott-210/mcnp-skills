---
title: "Chapter 2.11 - Random Numbers"
chapter: "2.11"
source_pdf: "mcnp631_theory_user-manual/mcnp-theory-manual-chapters/2_Geometry,_Data,_Physics,_and_Mathematics/2.11_Random_Numbers.pdf"
conversion_date: "2025-10-30"
converted_by: "Docling MCP Server + Claude"
notes: "Converted from MCNP6.3.1 documentation"
---

two straight lines. A separate set of parametric coefficients, C 1
through C 6 , is needed for each curve in such cases. The parametric
coefficients are found by transforming QM into yet another coordinate
system where most of its elements are zero. The parametric coefficients
are then simple functions [180] of the remaining elements. Finally, the
coefficients are transformed from that coordinate system back to the (
s, t ) system.

For a torus that can be plotted, the curves are either a pair of
identical ellipses or a pair of concentric circles. The parametric
coefficients are readily calculated from the surface coefficients and
the elements of QM are simple functions of the parametric coefficients.

The next step is to reject all curves that lie entirely outside the
window by finding the intersections of each curve with the straight line
segments that bound the window, taking into account the possibility that
an ellipse may lie entirely inside the window.

The remaining curves are plotted one at a time. The intersections of the
current curve, with all of the other remaining curves and with the
boundaries of the window, are found by solving the simultaneous
equations

<!-- formula-not-decoded -->

where i = 1 is the current curve and i = 2 is one of the other curves.
This process generally requires finding the roots of a quartic. False
roots and roots outside the window are rejected and the value of the
parameter p for each remaining intersection is found. The intersections
then are arranged in order of increasing values of p .

Each segment of the curve-the portion of the curve between two adjacent
intersections-is examined to see whether and how it should be plotted. A
point near the center of the segment is transformed back to the ( x, y,
z ) coordinate system. All cells immediately adjacent to the surface at
that point are found. If there is exactly one cell on each side of the
surface and those cells are the same, the segment is not plotted. If
there is exactly one cell on each side and those cells are different,
the segment is plotted as a solid line. If anything else is found, the
segment is plotted as a dotted line, which indicates either that there
is an error in the problem geometry or that some other surface of the
problem also intersects the plot plane along the segment.

If a curve to be plotted is not a straight line, it is plotted as a
sequence of short straight lines between selected points on the curve.
The points are selected according to the criterion that the middle of
the line drawn between points must not lie farther from the nearest
point on the true curve than the nominal resolution of the picture. The
maximum resolution is fixed at 1 / 5000 of a side of the viewport.

## 2.11 Random Numbers

Like any other Monte Carlo program, the MCNP code uses a sequence of
random numbers to sample from probability distributions. There are two
types of random number generators in the code: linear congruential
generators and SFC64. Their structure and behavior are different from
each other.

## 2.11.1 Linear Congruential Generators

The MCNP code has traditionally used the linear congruential scheme of
Lehmer [34], though the mechanics of implementation have been modified
for portability to different computer platforms. A random sequence of
integers I n is generated by

<!-- formula-not-decoded -->

where G is the random number multiplier, I 0 is the initial random seed,
C is an additive constant, and M -bit integers and M -bit floating point
mantissas are assumed. The random number is then

<!-- formula-not-decoded -->

The starting random number for history k is

<!-- formula-not-decoded -->

where S is the random number stride, that is, the number of random
numbers allocated to each single history. This initial random number
expression is evaluated very efficiently using a fast skip-ahead
algorithm [181]. Successive random numbers for history k are then

<!-- formula-not-decoded -->

The default values of G , M , I 0 , S , and C , which can be changed
with the RAND card, are

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

The values of G , M , and C are controlled by the GEN keyword. Generator
1 uses the above values, generators 2-4 use 63 bit integers and a
nonzero C , and generators 5-7 use 63 bit integers and a zero C [182]. I
0 is given by SEED , and S is given by STRIDE.

The period P of the MCNP algorithm using the default parameters is P = 2
46 ≈ 7 . 04 × 10 13 , and P = 2 63 ≈ 9 . 2 × 10 18 for the extended
random number parameters.

The MCNP code prints a WARNING and counts the number of histories for
which the stride S is exceeded. The MCNP code also prints a WARNING if
the period P is exceeded. Exceeding the stride or the period does not
result in wrong answers but may result in an underestimate of the
variance. However, because the random numbers are typically used for
different purposes, the MCNP code seems insensitive to overrunning
either the stride or the period [183] but poor behavior has been
observed for select problems [184].

Sometimes users wish to know how much of the variation between problems
is purely statistical and the variance is insufficient to provide this
information. In correlated sampling [§2.7.2.19] and criticality
problems, the variances can be underestimated because of correlation
between histories. In this case, rerun the problems with a different
random number sequence, either by starting with a new random number or
by changing the random number stride or multiplier on the RAND card. The
MCNP code checks for and does not allow invalid choices, such as an even
numbered initial random number that, after a few random numbers, would
result in all subsequent random numbers being zero.

## 2.11.2 SFC64

The SFC64 version 4 generator, which stands for 'Small, Fast, Counting,
64 bit output,' is a random invertible mapping generator written by
Chris Doty-Humphrey [185]. It is a 256 bit state generator that uses bit
level operations in its structure to advance its state:

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->

<!-- formula-not-decoded -->